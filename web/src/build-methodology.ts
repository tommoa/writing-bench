/**
 * Build-time script: converts methodology.md to a TypeScript module
 * exporting the rendered HTML string. LaTeX math ($...$ and $$...$$)
 * is rendered to HTML at build time via KaTeX.
 *
 * Usage: bun web/src/build-methodology.ts
 */
import { readFile, writeFile } from "fs/promises";
import { Marked } from "marked";
import katex from "katex";

const MD_PATH = new URL("../../METHODOLOGY.md", import.meta.url).pathname;
const OUT_PATH = new URL("./methodology-html.ts", import.meta.url).pathname;
const KATEX_CSS_URL = "https://cdn.jsdelivr.net/npm/katex@0.16.28/dist/katex.min.css";

const md = await readFile(MD_PATH, "utf-8");

// ── KaTeX rendering ────────────────────────────────

/** Render a LaTeX string to HTML via KaTeX. */
function renderLatex(latex: string, displayMode: boolean): string {
  try {
    return katex.renderToString(latex, {
      displayMode,
      throwOnError: false,
      output: "html",
    });
  } catch {
    // Fall back to escaped raw LaTeX if rendering fails
    return `<code>${escapeHtml(latex)}</code>`;
  }
}

/**
 * Extract LaTeX delimiters from raw Markdown, replacing them with
 * placeholders so that `marked` does not HTML-escape characters like
 * `<` inside math expressions. After marked runs, the placeholders are
 * swapped for KaTeX-rendered HTML via `restoreMath`.
 */
const mathStore: { placeholder: string; latex: string; display: boolean }[] = [];

function extractMath(markdown: string): string {
  // Display math: $$...$$
  markdown = markdown.replace(/\$\$([\s\S]+?)\$\$/g, (_, latex: string) => {
    const id = mathStore.length;
    const placeholder = `%%MATH:${id}%%`;
    mathStore.push({ placeholder, latex: latex.trim(), display: true });
    return placeholder;
  });

  // Inline math: $...$  (not preceded/followed by $)
  markdown = markdown.replace(/(?<!\$)\$(?!\$)((?:[^$\\]|\\.)+?)\$(?!\$)/g, (_, latex: string) => {
    const id = mathStore.length;
    const placeholder = `%%MATH:${id}%%`;
    mathStore.push({ placeholder, latex: latex.trim(), display: false });
    return placeholder;
  });

  return markdown;
}

function restoreMath(html: string): string {
  for (const { placeholder, latex, display } of mathStore) {
    const rendered = renderLatex(latex, display);
    html = html.replace(placeholder, () => rendered);
  }
  return html;
}

// ── Custom Marked renderer ─────────────────────────

const marked = new Marked();

marked.use({
  renderer: {
    // Map blockquotes to <p class="note">
    blockquote({ text }: { text: string }) {
      // Strip wrapping <p> tags that marked adds inside blockquotes
      const inner = text.replace(/^<p>/, "").replace(/<\/p>\s*$/, "");
      return `<p class="note">${inner}</p>\n`;
    },
  },
});

function escapeHtml(s: string): string {
  return s
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;");
}

const mdWithPlaceholders = extractMath(md);
const rawHtml = await marked.parse(mdWithPlaceholders);
const html = restoreMath(rawHtml);

const output = `// Auto-generated by build-methodology.ts — do not edit manually.
// Edit METHODOLOGY.md instead and run: bun web/src/build-methodology.ts

export const katexCssUrl = ${JSON.stringify(KATEX_CSS_URL)};

export const methodologyHtml = ${JSON.stringify(html)};
`;

await writeFile(OUT_PATH, output, "utf-8");
console.log(`wrote ${OUT_PATH}`);
